# Отчет по лабораторной работе 2

## Цель
Написать скрипт, который принимает IP-адрес в десятичном формате и выводит его в двоичном формате.

## Код скрипта
```bash
#!/bin/bash

# Этот скрипт проверяет корректность IP-адреса и преобразует его в двоичный формат.

# Запрашиваем у пользователя ввод IP-адреса.
read -p "Введите ваш IP-адрес: " ip

# Устанавливаем разделитель поля ввода на точку (.) для разделения IP-адреса на октеты.
IFS="."

# Разделяем IP-адрес на массив "mass".
mass=($ip)

# Инициализируем счетчик для неверных октетов.
count=0

# Проходим по каждому октету в массиве "mass".
for el in "${mass[@]}"; do
  # Проверяем, превышает ли октет значение 256 или количество октетов не равно 4.
  if [ $el -gt 256 ] || [ 4 -ne ${#mass[@]} ]; then
    # Увеличиваем счетчик, если найден неверный октет.
    count=$((count + 1))
  fi
done

# Проверяем, были ли найдены неверные октеты.
if [ $count -ne 0 ]; then
  # Выводим сообщение об ошибке, если IP-адрес неверный.
  echo "Неверный IP-адрес"
else
  # Преобразуем каждый октет в двоичный формат с помощью команды bc.
  for i in "${!mass[@]}"; do
    mass[$i]=$(bc <<< "obase=2; ibase=10; ${mass[$i]}")
  done

  # Выводим двоичное представление IP-адреса.
  for i in  "${!mass[@]}"; do
    echo -n "${mass[$i]}" # Выводим без перехода на новую строку
    if [ $i -lt $((${#mass[@]} - 1)) ]; then # Проверяем, является ли это последним октетом
      echo -n "." # Выводим точку, если это не последний октет
    fi
  done
  echo "" # Выводим перенос строки после последнего октета
fi
```

**Объяснение кода:**

1. **Заголовок:** `#!/bin/bash` указывает, что это скрипт Bash.
2. **Запрос ввода:** `read -p "Введите ваш IP-адрес: " ip` запрашивает у пользователя ввод IP-адреса и сохраняет его в переменной `ip`.
3. **Разделение IP-адреса:**
    * `IFS="."` устанавливает разделитель поля ввода на точку, чтобы IP-адрес был разделен на октеты при использовании в массиве.
    * `mass=($ip)` создает массив под названием `mass`, где каждый элемент представляет собой октет IP-адреса.
4. **Проверка корректности IP-адреса:**
    * `count=0` инициализирует счетчик для отслеживания неверных октетов.
    * Цикл `for` проходит по каждому элементу (`el`) в массиве `mass`:
        * `if [ $el -gt 256 ] || [ 4 -ne ${#mass[@]} ]; then ... fi` проверяет два условия:
            * `$el -gt 256`: Если октет больше 255, он неверен.
            * `4 -ne ${#mass[@]}`: Если количество октетов в массиве `mass` не равно 4, IP-адрес неверен.
        * Если одно из условий истинно, счетчик `count` увеличивается.
5. **Обработка неверного IP:**
    * `if [ $count -ne 0 ]; then ... fi` проверяет, были ли найдены неверные октеты.
    * Если `count` не равен 0, это означает, что были найдены неверные октеты, поэтому скрипт выводит "Неверный IP-адрес".
6. **Преобразование в двоичный формат:**
    * `for i in "${!mass[@]}"; do ... done` проходит по индексам (`i`) массива `mass`:
        * `mass[$i]=$(bc <<< "obase=2; ibase=10; ${mass[$i]}")`: Эта команда использует команду `bc` для преобразования каждого октета (в десятичном формате) в двоичный.
            * `obase=2; ibase=10` устанавливает выходную базу в 2 (двоичный) и входную базу в 10 (десятичный).
            * `${mass[$i]}` - это десятичное значение октета.
7. **Вывод двоичного представления:**
    * Скрипт снова проходит по массиву `mass`, на этот раз выводя каждый октет в двоичном виде:
        * `echo -n "${mass[$i]}"` выводит двоичное представление октета без перехода на новую строку.
        * `if [ $i -lt $((${#mass[@]} - 1)) ]; then ... fi` проверяет, является ли это последним октетом. Если это не последний октет, то выводится точка, чтобы разделить октеты.
    * `echo ""` выводит перенос строки после последнего октета.

**Пример использования:**

```
Введите ваш IP-адрес: 192.168.1.1
11000000.10101000.00000001.00000001
```

### Основные концепции
- **IP-адрес**: Это уникальный идентификатор устройства в сети. IPv4 состоит из 4 частей, каждая из которых принимает значения от 0 до 255.
  
- **Маска подсети**: Используется для определения сетевой части IP-адреса. Например, маска 255.255.255.0 соответствует `/24`, где первые 24 бита используются для идентификации сети, а оставшиеся 8 - для идентификации узлов в сети.


